/* (c) Copyright 2003-2019, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_fastBuffer_impl.h    generated by: makeheader    Fri Nov 15 12:21:47 2019
 *
 *		built from:	fastBuffer_impl.ifc
 */

#ifndef reda_fastBuffer_impl_h
#define reda_fastBuffer_impl_h


#ifdef __cplusplus
    extern "C" {
#endif



/* TODO: does not check for overflow */
#define REDAFastBufferPoolGrowthProperty_add(__answer, __left, __right) \
{ \
    if ((__left)->initial != REDA_FAST_BUFFER_POOL_UNLIMITED && \
        (__right)->initial != REDA_FAST_BUFFER_POOL_UNLIMITED) { \
        (__answer)->initial = (__left)->initial + (__right)->initial; \
    } else { \
        (__answer)->initial = REDA_FAST_BUFFER_POOL_UNLIMITED; \
    } \
    if ((__left)->maximal != REDA_FAST_BUFFER_POOL_UNLIMITED && \
        (__right)->maximal != REDA_FAST_BUFFER_POOL_UNLIMITED) { \
        (__answer)->maximal = (__left)->maximal + (__right)->maximal; \
    } else { \
        (__answer)->maximal = REDA_FAST_BUFFER_POOL_UNLIMITED; \
    } \
    if ((__left)->increment != REDA_FAST_BUFFER_POOL_UNLIMITED && \
        (__right)->increment != REDA_FAST_BUFFER_POOL_UNLIMITED) { \
        (__answer)->increment = (__left)->increment + (__right)->increment; \
    } else { \
        (__answer)->increment = REDA_FAST_BUFFER_POOL_UNLIMITED; \
    } \
}

/* 
 * Increase the initial and maximal values for the growth property, checking
 * for overflow.
 * 
 * If the increase overflows INT_MAX, then the value is set to UNLIMITED.
 * 
 * Property consistency is not checked (e.g. that the resulting initial <= max)
 * This should be checked when the property is actually used
 */
#define REDAFastBufferPoolGrowthProperty_increase( \
        __prop, \
        __initialIncrease, \
        __maxIncrease) \
{ \
    if ((__prop)->initial != REDA_FAST_BUFFER_POOL_UNLIMITED) { \
        if ((RTI_INT32_MAX - (__initialIncrease)) >= (__prop)->initial) { \
            (__prop)->initial += (__initialIncrease); \
        } else { \
            (__prop)->initial = REDA_FAST_BUFFER_POOL_UNLIMITED; \
        } \
    } \
    if ((__prop)->maximal != REDA_FAST_BUFFER_POOL_UNLIMITED) { \
        if ((RTI_INT32_MAX - (__maxIncrease)) >= (__prop)->maximal) { \
            (__prop)->maximal += (__maxIncrease); \
        } else { \
            (__prop)->maximal = REDA_FAST_BUFFER_POOL_UNLIMITED; \
        } \
    } \
}

#define REDAFastBufferPoolGrowthProperty_compare(left, right) \
    (((left)->initial > (right)->initial) ? 1 : \
     (((left)->initial < (right)->initial) ? -1 : \
      (((left)->maximal > (right)->maximal) ? 1 : \
       (((left)->maximal < (right)->maximal) ? -1 : \
        (((left)->increment > (right)->increment) ? 1 : \
         (((left)->increment < (right)->increment) ? -1 : 0))))))

#define REDAFastBufferPool_newForStructure(structType, \
                                           propertyIn) \
    REDAFastBufferPool_new(sizeof(structType), \
                           RTIOsapiAlignment_getAlignmentOf(structType), \
	                   propertyIn)

#define REDAFastBufferPoolGrowthProperty_verify(me_) \
    ((((me_)->initial > 0) || ((me_)->initial == REDA_FAST_BUFFER_POOL_AUTO)) \
     && ((me_)->maximal < 0 || (me_)->initial <= (me_)->maximal))

/* --------------------------------------------------------- */
  #define REDAFastBufferGrowthProperty_limitExceeded(p_, current_) \
      (((p_)->maximal >= 0) && ((current_) > (p_)->maximal))

/* --------------------------------------------------------- */
  #define REDAFastBufferGrowthProperty_limitReached(p_, current_) \
      (((p_)->maximal >= 0) && ((current_) >= (p_)->maximal))

#define REDAFastBufferPool_getBuffer(me_) \
    REDAFastBufferPool_getBufferWithSize(me_, REDA_FAST_BUFFER_POOL_BUFFER_SIZE_AUTO)



#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* reda_fastBuffer_impl_h */
