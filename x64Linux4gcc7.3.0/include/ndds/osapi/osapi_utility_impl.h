/* (c) Copyright 2003-2019, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)osapi_utility_impl.h    generated by: makeheader    Fri Nov 15 12:21:38 2019
 *
 *		built from:	utility_impl.ifc
 */

#ifndef osapi_utility_impl_h
#define osapi_utility_impl_h





#ifdef __cplusplus
    extern "C" {
#endif


#define RTIOsapiUtility_max(l, r) (((l) > (r)) ? (l) : (r))
#define RTIOsapiUtility_min(l, r) (((l) < (r)) ? (l) : (r))
#define RTIOsapiUtility_abs(l) (((l) < 0) ? (-(l)) : (l))
#define RTIOsapiUtility_isWithinBound(n, lower, upper) (((n) >= (lower)) \
                                                        && ((n) <= (upper)))

#define RTIOsapiUtility_getSpaceLeft(length, max) \
    (((max) > (length)) \
            ? ((max) - (length)) \
            : 0)

#define RTIOsapiUtility_strlen(str) \
    (str == NULL ? 0 : strlen(str))

#define RTIOsapiUtility_strstr(src, pattern) \
    (src == NULL || pattern == NULL ? NULL : strstr(src, pattern))

#define RTIOsapiUtility_assertSpaceLeft(length, max, bytesToAssert) \
        (RTIOsapiUtility_getSpaceLeft(length, max) >= (bytesToAssert))

#define RTIOsapiUtility_unusedParameter(parameter) (void) parameter

/*
 * Use this macro to remove warnings in situations where 
 * a function is assigning its return value to a variable but 
 * the variable is not being used anywhere. This will produce a
 * "set-but-unused variable warning".
 * 
 * @param function The function returning a value which is not being used
 * @param type     The type of the expected return value of function
 *
 */
#define RTIOsapiUtility_unusedReturnValue(function, type) \
{                                                         \
    type unusedReturnValue;                               \
    unusedReturnValue = function;                         \
    (void)unusedReturnValue;                              \
} (void)0

/*
 * Use these macros to remove strict-aliasing warnings. You may not dereference
 * a pointer that was casted to the wrong type, but you may assign a casted
 * pointer to a pointer of the correct type and then dereference that
 * correct-type pointer. This method should be more performant than calling
 * memcpy.
 */

#define RTIOsapiUtility_assignValueFromDereference(__dst, __srcPtr, __dstType) { \
    __dstType *__srcPtrTyped = (__dstType *) (__srcPtr); \
    __dst = *__srcPtrTyped; \
}

#define RTIOsapiUtility_assignDereferenceFromValue(__dstPtr, __src, __srcType) { \
    __srcType *__dstPtrTyped = (__srcType *) (__dstPtr); \
    *__dstPtrTyped = (__src); \
}

#define RTIOsapiUtility_assignDereferenceFromDereference(__dstPtr, __srcPtr, __dstType) { \
    __dstType *__dstPtrTyped = (__dstType *) (__dstPtr); \
    __dstType *__srcPtrTyped = (__dstType *) (__srcPtr); \
    *__dstPtrTyped = *__srcPtrTyped; \
}

/* Expands to the number of elements in an array */
#define RTIOsapiUtility_arraySize(x) (sizeof(x)/sizeof(x[0]))

/* Expands to a string representation of s */
#define RTIOsapiUtility_stringify(s) RTIOsapiUtility_s(s)
#define RTIOsapiUtility_s(s) #s

/* Following CORE-7848 */
#ifdef RTI_WIN32
  #define RTIOsapiUtility_sscanf sscanf_s
#else
  #define RTIOsapiUtility_sscanf sscanf
#endif



#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* osapi_utility_impl_h */
