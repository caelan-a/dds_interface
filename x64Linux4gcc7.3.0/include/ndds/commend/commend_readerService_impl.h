/* (c) Copyright 2003-2019, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)commend_readerService_impl.h    generated by: makeheader    Fri Nov 15 12:22:18 2019
 *
 *		built from:	readerService_impl.ifc
 */

#ifndef commend_readerService_impl_h
#define commend_readerService_impl_h


  #ifndef osapi_bufferUtils_h
    #include "osapi/osapi_bufferUtils.h"
  #endif
  #ifndef mig_interpreter_h
    #include "mig/mig_interpreter.h"
  #endif
#ifdef __cplusplus
    extern "C" {
#endif



#define COMMENDReaderServiceProperty_copy(to, from) \
    RTIOsapiMemory_copy(to, from, sizeof(struct COMMENDReaderServiceProperty))

/*
 * SEC-959: If the submessage contains the serialized value of a data object or
 * its key, make sure that we at least have space for the encapsulation header.
 */
#define COMMENDReaderServiceData_checkSize( \
        __context, \
        __availableSpace, \
        __returnIfError) \
    /*
     * Check availableSpace first because this condition is not as common as
     * the submessageFlags condition. Don't check the submessageId because this
     * macro is always called in the context of processing a DATA submessage.
     */ \
    if ((__availableSpace) < RTI_CDR_ENCAPSULATION_HEADER_SIZE) { \
        if (((__context)->submessageFlags & MIG_RTPS_DATA_D_FLAG) \
            || ((__context)->submessageFlags & MIG_RTPS_DATA_K_FLAG)) { \
            COMMENDLog_warn( \
                    &RTI_LOG_INSUFFICIENT_SPACE_FAILURE_dd, \
                    __availableSpace, \
                    RTI_CDR_ENCAPSULATION_HEADER_SIZE); \
            __returnIfError; \
        } \
    }

#define COMMENDReaderServiceData_set( \
        me, \
        context, \
        sn, \
        vSn, \
        setFirstSn, \
        batchSnOffset, \
        statusInfo, \
        userData, \
        parameter, \
        batchSampleInfo, \
        var, \
        serializedData, \
        returnIfError) \
  COMMENDReaderServiceData_checkSize( \
          context, \
          (userData)->length, \
          returnIfError); \
  (me)->writer.prefix.hostId   = (context)->sourceHostId;                 \
  (me)->writer.prefix.appId    = (context)->sourceAppId;                  \
  (me)->writer.prefix.instanceId    = (context)->sourceInstanceId;        \
  (me)->writer.objectId = (context)->writerObjectId;                      \
  (me)->reader.prefix.hostId   = (context)->destinationHostId;            \
  (me)->reader.prefix.appId    = (context)->destinationAppId;             \
  (me)->reader.prefix.instanceId    = (context)->destinationInstanceId;   \
  (me)->reader.objectId = (context)->readerObjectId;                      \
  MIGGeneratorSample_set(&((me)->sample), (sn), (setFirstSn), vSn , batchSnOffset, (var), \
        ((context)->haveTimestamp ? &((context)->timestamp) : NULL),      \
        NULL, (context)->submessageFlags, (context)->dataExtraFlags,   \
        (statusInfo), (userData), (parameter), NULL, NULL, batchSampleInfo, (serializedData));



#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* commend_readerService_impl_h */
