/* (c) Copyright 2003-2021, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)advlog_logger.h    generated by: makeheader    Fri Apr 23 00:04:25 2021
 *
 *		built from:	logger.ifc
 */

#ifndef advlog_logger_h
#define advlog_logger_h


  #include <stdlib.h>
  #include <stdio.h>

  #ifndef osapi_thread_h
    #include "osapi/osapi_thread.h"
  #endif

  #ifndef reda_worker_h
    #include "reda/reda_worker.h"
  #endif
  
  #ifndef advlog_dll_h
    #include "advlog/advlog_dll.h"
  #endif

  #ifndef log_common_h
    #include "log/log_common.h"
  #endif
  #ifndef clock_interface_h
    #include "clock/clock_interface.h"
  #endif

  #ifdef __cplusplus
    extern "C" {
  #endif

struct ADVLOGMessageInfo;


#define ADVLOG_NUM_BULTIN_DEVICE_KINDS (3)


#define ADVLOG_LOGGER_MAX_DEVICES (10)


  #define ADVLOG_LOGGER_MESSAGE_COUNT_MAX  10      /* max number of errors or warnings 
                                                      stored in the queue*/
/* Max number of pointers to function name stored in the queue */
#define ADVLOG_LOGGER_FUNCTION_HISTORY_COUNT_MAX  20

typedef enum {
    /* WARNING: any changes to this must be reflected in  
       ADVLOG_NUM_BULTIN_DEVICE_KINDS */
    ADVLOG_LOGGER_SLOT_MEMORY   = 1,
    ADVLOG_LOGGER_SLOT_FILE     = 3,
    ADVLOG_LOGGER_SLOT_STDIO    = 7
    /* WARNING: any changes to this must be reflected in  
       ADVLOG_NUM_BULTIN_DEVICE_KINDS */
} ADVLOGLoggerBuiltinSlotValues ;

typedef enum {
    ADVLOG_LOGGER_UNKNOWN_LOGGING_STATE,
    ADVLOG_LOGGER_LOGGING_MESSAGE,
    ADVLOG_LOGGER_CLOSING_DEVICE,
    ADVLOG_LOGGER_IDLE_AFTER_LOGGING,
    ADVLOG_LOGGER_IDLE_AFTER_CLOSING
} ADVLOGLoggerLoggingState;

struct ADVLOGLoggerDevice;

typedef void (*ADVLOGLoggerDeviceWriteFnc)(
        struct ADVLOGLoggerDevice *device,
        struct REDAWorker *worker,
        const  struct ADVLOGMessageInfo *msg);

typedef void (*ADVLOGLoggerDeviceCloseFnc)(
        struct ADVLOGLoggerDevice *device,
        struct REDAWorker *worker);


struct ADVLOGLoggerDevice {
    /*e Identify device. Number below 100 are reserved for built-in devices.*/
    int deviceKind;
    /*e Write a logged message to this device.*/
    ADVLOGLoggerDeviceWriteFnc writeFnc;
    /*e Close this device.*/
    ADVLOGLoggerDeviceCloseFnc closeFnc;
};

struct ADVLOGWorkerProvider;

typedef struct REDAWorker *(*ADVLOGWorkerProvider_GetWorkerFunction)(
        struct ADVLOGWorkerProvider *self);

typedef struct REDAWorker * (*ADVLOGWorkerProvider_CreateWorkerFunction)(
        struct ADVLOGWorkerProvider *self,
        const char *name);

typedef void (*ADVLOGWorkerProvider_DestroyWorkerFunction)(
        struct ADVLOGWorkerProvider *self,
        struct REDAWorker *worker);

typedef void (*ADVLOGWorkerProvider_AssociateWorkerFunction)(
        struct ADVLOGWorkerProvider *self,
        struct REDAWorker *worker);

struct ADVLOGWorkerProvider {
    ADVLOGWorkerProvider_GetWorkerFunction getWorker;
    ADVLOGWorkerProvider_CreateWorkerFunction createWorker;
    ADVLOGWorkerProvider_DestroyWorkerFunction destroyWorker;
    ADVLOGWorkerProvider_AssociateWorkerFunction associateWorker;
    void *data;
};

struct ADVLOGMessageInfo {
    char message[RTI_LOG_MSG_SIZE_MAX];
    RTILogLevel logLevel;
};

extern ADVLOGDllExport
RTIBool ADVLOGLogger_preinit(void);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_init(struct REDAWorkerFactory *workerFactory,
                          struct ADVLOGWorkerProvider *workerProvider,
                          struct RTIClock *timestampClock,
                          RTIOsapiThreadTssFactory * tssFactory);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_install(void);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_uninstall(void);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_finalize(struct REDAWorker * worker);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setDevice(int slot, struct ADVLOGLoggerDevice *device,
        struct REDAWorker *worker, RTIBool workerSpecific);

extern ADVLOGDllExport
struct ADVLOGLoggerDevice *ADVLOGLogger_getDevice(int slot);

extern ADVLOGDllExport
RTILogPrintFormatKindMask ADVLOGLogger_getPrintMask(
        struct REDAWorker *worker,
        RTIBool workerSpecific);

extern ADVLOGDllExport
RTILogPrintFormatKindMask ADVLOGLogger_getPrintMaskByLogLevel(
        RTILogLevel logLevel,
        struct REDAWorker *worker,
        RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setPrintMask(
        RTILogPrintFormatKindMask mask,
        struct REDAWorker *worker,
        RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setPrintMaskByLogLevel(
        RTILogPrintFormatKindMask mask,
        RTILogLevel logLevel,
        struct REDAWorker *worker,
        RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setDeviceBuiltinFile(FILE *file,
        RTI_UINT32 maxCapacity, struct REDAWorker *worker, RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setDeviceBuiltinMemory(char *buffer,
        RTI_UINT32 maxCapacity, struct REDAWorker *worker, RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setDeviceBuiltinStdio(struct REDAWorker *worker,
                                           RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setThreadLogAlsoToGlobal(struct REDAWorker *worker,
                                              RTIBool sendAlsoToGlobal);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setLoggingState(
        RTI_INT8 *stateToken,
        struct REDAWorker *worker,
        ADVLOGLoggerLoggingState state);


/*e Define bits used by RTILOG
   @brief non-ADVLOG print bit mask
*/
#define ADVLOG_PRINT_MASK_RTILOG     0xf00000ff
/*e Define bits used by ADVLOG
   @brief ADVLOG-only print bit mask
*/
#define ADVLOG_PRINT_MASK            0xf000ff00

/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Print a timestamp
*/
#define ADVLOG_PRINT_BIT_TIMESTAMP   0x100
/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Print thread ID
*/
#define ADVLOG_PRINT_BIT_THREAD_ID   0x200
/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Print the context stack state
*/
#define ADVLOG_PRINT_BIT_ACTIVITY_CONTEXT     0x400
/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Print the context stack state
*/
#define ADVLOG_PRINT_BIT_TWO_LINES   0x800

/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Default ADVLOG print mask
*/
#define ADVLOG_PRINT_MASK_DEFAULT    (ADVLOG_PRINT_BIT_ACTIVITY_CONTEXT)

/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief ADVLOG print mask value to force use of global default
*/
#define ADVLOG_PRINT_MASK_USE_DEFAULT RTI_LOG_PRINT_COMMON_BIT_USE_DEFAULT


/*e \ingroup ADVLOGLoggerModule

   @brief register a worker to be associated with the current thread
*/
extern ADVLOGDllExport
RTIBool ADVLOGLogger_associateWorkerWithCurrentThread(struct REDAWorker *worker);


/*i \ingroup ADVLOGLoggerModule

   @brief ADVLOG version of printContextAndMsg [NOT YET IMPLEMENTED]

   If worker is NULL, it will be looked up; this is functionally equivalent
   to calling the RTILog version of this function when ADVLOG is installed.

   If ADVLOG has not yet been initialized, the call is passed to RTILog.
*/
Peer ADVLOGDllExport
RTIBool ADVLOGLogger_printContextAndMsg(struct REDAWorker *worker,
                                        const char *context,
                                        const struct RTILogMessage *errMsg, ...);

/*i \ingroup ADVLOGLoggerModule

   @brief ADVLOG version of printLocationContextAndMsg [NOT YET IMPLEMENTED]

   If worker is NULL, it will be looked up; this is functionally equivalent
   to calling the RTILog version of this function when ADVLOG is installed.

   If ADVLOG has not yet been initialized, the call is passed to RTILog.
*/
Peer ADVLOGDllExport
RTIBool ADVLOGLogger_printLocationContextAndMsg(struct REDAWorker *worker,
                                        RTI_UINT32 module, const char *filename,
                                        const char *method, RTI_UINT32 lineno,
                                        const struct RTILogMessage *errMsg, ...);

/*e \ingroup ADVLOGLoggerModule

   @brief Function to explicitly output timestamp.

   If worker is NULL, it will be looked up.

   If ADVLOG has not yet been initialized, the call will fail.
*/
extern ADVLOGDllExport
RTIBool ADVLOGLogger_printTimestamp(
        struct REDAWorker *worker,
        const char *context,
        RTILogLevel logLevel);


/*e \ingroup ADVLOGLoggerModule 
   @brief This method will return the last n error or warning messages or
   simply calculate the amount of space needed to hold the last n error
   messages.
 
   If worker is NULL, it will be looked up.
 
   If stackMessage is NULL then the length will be calcualted and returned in
   len. Otherwise, stackMessage will be populated with the last n error or
   warnign messages, each on their own line, with increasing indentation. 
 
   If stackMessage is NULL, len will be returned with the length needed to store
   the last n error or warning messages. Otherwise, len should equal the amount
   of available space and the actual length of the string will be returned. 

   If ADVLOG has not yet been initialized, the call will fail.
*/ 
extern ADVLOGDllExport
void ADVLOGLogger_getLastErrorMessages(
   struct REDAWorker *worker, char* stackMessage, RTI_INT32 *size);


/* The messageInfos for errors and warning are stored in the
   logger as a circular queue. The circular queue is implemented
   on top of an array of messageInfo structure. Whenever a new
   error/warning is encountered the start index of the array is
   advanced and the information about the error or the warning
   is then stored in the location pointed by the start index.
*/

/*e \ingroup ADVLOGLoggerModule 
   @brief This method will clear the ADVLOGMessageInfo queue
   associated with the worker.
 
   If worker is NULL, it will be looked up.

   If ADVLOG has not yet been initialized, the call will fail.
*/ 
extern ADVLOGDllExport
void
ADVLOGLogger_emptyMessageInfoQueue(struct REDAWorker *worker);


extern ADVLOGDllExport
struct REDAWorker* ADVLOGLogger_getWorker(void);


extern ADVLOGDllExport
struct REDAWorker * ADVLOGLogger_createWorker(const char *name);


extern ADVLOGDllExport
void ADVLOGLogger_destroyWorker(struct REDAWorker *worker);


/*e \ingroup ADVLOGLoggerModule
   @brief Enable:
        - Save a pointer to the method name in a queue everytime a precondition
             is called using "ADVLOGLogger_addToFunctionHistory"
        - Log the function history when is requiered using
            "ADVLOGLogger_logFunctionHistory"

    @return RTI_TRUE on success.
        RTI_FALSE on failure enabling the Function History feature.
*/
extern ADVLOGDllExport
RTIBool ADVLOGLogger_enableFunctionHistory(void);


/*e \ingroup ADVLOGLoggerModule
    Disable:
        - Save a pointer to the method name in a queue everytime a precondition
             is called using "ADVLOGLogger_addToFunctionHistory"
        - Log the function history when is requiered using
            "ADVLOGLogger_logFunctionHistory"
*/
extern ADVLOGDllExport
void ADVLOGLogger_disableFunctionHistorySupport(void);




  #ifdef __cplusplus
    }	/* extern "C" */
  #endif

#endif /* advlog_logger_h */
