/* (c) Copyright 2003-2021, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)osapi_context_impl.h    generated by: makeheader    Fri Apr 23 00:09:52 2021
 *
 *		built from:	context_impl.ifc
 */

#ifndef osapi_context_impl_h
#define osapi_context_impl_h


#ifdef __cplusplus
    extern "C" {
#endif



/*i \ingroup RTIOsapiContextSupport
 * It is a counter which specify how many times the context support has been
 * initialized.
 * It is used to disable the context support only when it is 1, it makes sure
 * RTIOsapiContextSupport_disable() will not be called more after it.
 */
extern RTIOsapiDllVariable
RTI_UINT32 RTIOsapiContextSupport_g_tssInitializedRefCount;

extern RTIOsapiDllVariable
RTI_UINT32 RTIOsapiContextSupport_g_tssKey;


/*i \ingroup RTIOsapiContext
 * Number of type of contexts.
 * Instantiate different specializations of the context:
 * - Activity context: it will describe the activity that a resource is doing.
 * - Heap context: it will represent: If the allocation is from the pool and in
 * that case the buffer size and the buffer count. The topic and the function name.
 *- In the future, we can have more potential context families for instance
 * network capture context.
 */

#define RTI_OSAPI_NUMBER_CONTEXTS 3


/*i \ingroup RTIOsapiContextSupport
 * Each node contains the contexts of the thread.
 */

struct RTIOsapiContextSupportNode {
    struct RTIOsapiInlineListNode node;
    struct RTIOsapiContext *contexts[RTI_OSAPI_NUMBER_CONTEXTS];
};


/*
 * @brief It is a macro to get the context of the caller thread, specified by
 * the Id.
 * It is used in the critical path and in the function:
 *      RTIOsapiContextSupport_getContext
 *
 * @param contextIndex \b In. The index of the context.
 * @param the context \b Out. The context.
 */
#define RTIOsapiContextSupport_getContextI( \
        __contextIndex, \
        __context) \
    { \
        if (RTIOsapiContextSupport_g_tssInitializedRefCount > 0) { \
            struct RTIOsapiContextSupportNode *__node = \
                    (struct RTIOsapiContextSupportNode *) RTIOsapiThread_getTss( \
                            RTIOsapiContextSupport_g_tssKey); \
            if (__node != NULL) { \
                __context = __node->contexts[__contextIndex]; \
            } \
        } \
    }

#define RTIOsapiContextScope_begin() \
    {

#define RTIOsapiContextScope_end() \
    }

#define RTIOsapiContext_enterPairMacro( \
        __self, \
        __contextIndex, \
        __entry1, \
        __entry2) \
    { \
        struct RTIOsapiContext *__context = (__self); \
        if ((__context) == NULL) { \
            RTIOsapiContextSupport_getContextI((__contextIndex), (__context)); \
        } \
        if ((__context) != NULL) { \
            if ((__context)->top + 2 <= (__context)->maxEntryCount) { \
                struct RTIOsapiContextEntry *__entry = \
                        &(__context)->entries[(__context)->top]; \
                /* Enter entry 1 */ \
                __entry[0].entry = (__entry1); \
                __entry[0].expansionEnd = NULL; /* no cached expansion */ \
                /* Enter entry 2 */ \
                __entry[1].entry = (__entry2); \
                __entry[1].expansionEnd = NULL; /* no cached expansion */ \
            } \
            (__context)->top += 2; \
        } \
    }

#ifndef RTI_PRECONDITION_TEST
  #define RTIOsapiContext_enterPair RTIOsapiContext_enterPairMacro
#endif

#define RTIOsapiContext_leaveGroupMacro( \
        __self, \
        __contextIndex, \
        __groupSize) \
    { \
        if ((__groupSize) > 0) { \
            struct RTIOsapiContext *__context = (__self); \
            if (__context == NULL) { \
                RTIOsapiContextSupport_getContextI((__contextIndex), (__context)); \
            } \
            if ((__context) != NULL) { \
                RTI_UINT32 __groupSizeI = (__groupSize); \
                while ((__context)->top > (__context)->maxEntryCount && (__groupSizeI) > 0) { \
                    (__context)->top--; \
                    (__groupSizeI)--; \
                } \
                while ((__context)->top > 0 && (__groupSizeI) > 0) { \
                    (__context)->entries[--(__context)->top].expansionEnd = NULL; \
                    (__groupSizeI)--; \
                } \
            } \
        } \
    }

#ifndef RTI_PRECONDITION_TEST
  #define RTIOsapiContext_leaveGroup RTIOsapiContext_leaveGroupMacro
#endif



#ifdef __cplusplus
    }	/* extern "C" */
#endif


#endif /* osapi_context_impl_h */
