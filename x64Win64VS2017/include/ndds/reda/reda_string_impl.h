/* (c) Copyright 2003-2021, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_string_impl.h    generated by: makeheader    Fri Apr 23 00:10:56 2021
 *
 *		built from:	string_impl.ifc
 */

#ifndef reda_string_impl_h
#define reda_string_impl_h


#ifdef __cplusplus
    extern "C" {
#endif


  #include "osapi/osapi_type.h"
  typedef RTI_INT8 utf8proc_int8_t;
  typedef RTI_UINT8 utf8proc_uint8_t;
  typedef RTI_INT16 utf8proc_int16_t;
  typedef RTI_UINT16 utf8proc_uint16_t;
  typedef RTI_INT32 utf8proc_int32_t;
  typedef RTI_UINT32 utf8proc_uint32_t;
  #if defined(RTI_64BIT)
    typedef RTI_INT64 utf8proc_ssize_t;
    typedef RTI_UINT64 utf8proc_size_t;
  #else
    typedef RTI_INT32 utf8proc_ssize_t;
    typedef RTI_UINT32 utf8proc_size_t;
  #endif
  typedef RTI_UINT8 utf8proc_bool;

extern REDADllExport 
utf8proc_ssize_t utf8proc_iterate(
        const utf8proc_uint8_t *str, 
        utf8proc_ssize_t strlen, 
        utf8proc_int32_t *codepoint_ref);


#define REDAString_getCharAndNext(__str, __c, __encodingSize, __encodingKind) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) *(__str); \
 \
    if ((__encodingKind) != REDA_CHARACTER_ENCODING_UTF8 || *ustr < 0x80) { \
        *(__c) = (RTI_INT32) *ustr; \
        *(__encodingSize) = 1; \
        ++(*(__str)); \
    } else { \
        *(__encodingSize) = (RTI_INT32) utf8proc_iterate( \
                ustr, \
                -1, \
                (utf8proc_int32_t *)(__c)); \
        if (*(__encodingSize) < 0) { \
            /* Errors are handled by advancing one character */ \
            *(__c) = (RTI_INT32)*ustr; \
            *(__encodingSize) = 1; \
            ++(*(__str)); \
        } else { \
            *(__str) += *(__encodingSize); \
        } \
    } \
}

#define REDAString_nextChar(__str, __encodingKind) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) *(__str); \
 \
    if ((__encodingKind) != REDA_CHARACTER_ENCODING_UTF8 || *ustr < 0x80) { \
        ++(*(__str)); \
    } else { \
        utf8proc_int32_t __c; \
        utf8proc_ssize_t __size; \
        __size = utf8proc_iterate(ustr, -1, &__c); \
 \
        if (__size < 0) { \
            /* Errors are handled by advancing one character */ \
            ++(*(__str)); \
        } else { \
            *(__str) += __size; \
        } \
    } \
}

#define REDAString_prevChar(__str, __encodingKind) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) *(__str); \
 \
    if ((__encodingKind) != REDA_CHARACTER_ENCODING_UTF8) { \
        --(*(__str)); \
    } else { \
        int __i; \
        utf8proc_ssize_t __size; \
        RTI_INT32 __c; \
 \
        for (__i=1; __i<=4; __i++) { \
            __size = utf8proc_iterate(ustr - __i, -1, &__c); \
 \
            if (__size > 0) { \
                *(__str) -= __size; \
                break; \
            } \
        } \
 \
        if (__i==5) { \
            /* Errors are handled by going back one character */ \
            --(*(__str)); \
        } \
    } \
}

#define REDAString_getChar(__str, __c, __encodingSize, __encodingKind) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) (__str); \
 \
    if ((__encodingKind) != REDA_CHARACTER_ENCODING_UTF8 || *ustr < 0x80) { \
        *(__c) = (RTI_INT32) *ustr; \
        *(__encodingSize) = 1; \
    } else { \
        *(__encodingSize) = utf8proc_iterate(ustr, -1, (utf8proc_int32_t *) (__c)); \
        if (*(__encodingSize) < 0) { \
            /* Errors are handled by returning a single byte charactetr */ \
            *(__c) = (RTI_INT32) *ustr; \
            *(__encodingSize) = 1; \
        } \
    } \
}

#define REDAString_getCharAt( __str, __c,  __encodingSize, __position, __encodingKind) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) (__str); \
 \
    if ((__encodingKind) != REDA_CHARACTER_ENCODING_UTF8) { \
        *(__c) = (RTI_INT32) ustr[(__position)]; \
        *(__encodingSize) = 1; \
    } else { \
        int __i; \
        for (__i=0; __i<(__position); __i++) { \
            *(__encodingSize) = (RTI_INT32) utf8proc_iterate( \
                    ustr, \
                    -1, \
                    (utf8proc_int32_t *) (__c)); \
 \
            if (*(__encodingSize) < 0) { \
                break; \
            } \
 \
            ustr += *(__encodingSize); \
        } \
 \
        if (__i==(__position)) { \
            *(__encodingSize) = (RTI_INT32) utf8proc_iterate( \
                    ustr, \
                    -1, \
                    (utf8proc_int32_t *) (__c)); \
        } \
 \
        if (*(__encodingSize) < 0) { \
            /* Errors are handled by returning a single byte charactetr */ \
            ustr = (const utf8proc_uint8_t *)(__str); \
            *(__c) = (RTI_INT32)ustr[(__position)]; \
            *(__encodingSize) = 1; \
        } \
    } \
}


#define REDAChar_toLower(__c) \
    (((__c) < 0x80)? tolower((__c)): (RTI_INT32) utf8proc_tolower((__c)))


#define REDAChar_toUpper(__c) \
    (((__c) < 0x80) ? toupper((__c)) : (RTI_INT32) utf8proc_toupper((__c)))


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* reda_string_impl_h */
