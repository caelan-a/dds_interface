/* (c) Copyright 2003-2021, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_string.h    generated by: makeheader    Fri Apr 23 00:10:56 2021
 *
 *		built from:	string.ifc
 */

#ifndef reda_string_h
#define reda_string_h


  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif
  #ifndef reda_dll_h
    #include "reda/reda_dll.h"
  #endif

  #include <stdio.h>

#ifdef __cplusplus
    extern "C" {
#endif

extern REDADllExport
int REDAString_isspace(int ch);

extern REDADllExport
const char * REDAString_skipSpaces(const char *str);

extern REDADllExport
const char * REDAString_skipWord(const char *str, const char *word);

extern REDADllExport const char*
REDAString_getToken(int *tokenLength, const char *s, char c);

extern REDADllExport const char*
REDAString_getLastToken(const char *str, char separator);

extern REDADllExport int
REDAString_getTokenCount(const char *str, char separator);

extern REDADllExport RTIBool REDAString_hasCommonElement(
    const char* delimitorSeparatedString1,
    const char* delimitorSeparatedString2,
    char delimitor);

extern REDADllExport RTIBool REDAString_hasMatchingElement(
    const char* delimitorSeparatedString1,
    const char* delimitorSeparatedString2,
    char delimitor);

extern REDADllExport RTIBool REDAString_hasIntersectingPattern(
    const char* delimitorSeparatedString1,
    const char* delimitorSeparatedString2,
    char delimitor,
    void* param);

extern REDADllExport RTIBool REDAString_isPattern(const char *str);

extern REDADllExport RTIBool
REDAString_hasPatternsOnly(const char* s, char c);

extern REDADllExport char* REDAString_duplicate(const char* s);

extern REDADllExport char* REDAString_replace(
        char** dest,
        const char *source);

extern void REDAString_trimEnd(char * s);

extern REDADllExport void REDAString_printBytes(const char *buffer,
						int bufferSize);

extern REDADllVariable const int REDA_STRING_INDENT_AMOUNT;

extern REDADllExport void REDAString_printIndent(int indent);

extern REDADllExport void REDAString_printSpace(int count);

extern REDADllExport
int REDAString_compare(const char* s1, const char* s2);

extern REDADllExport int REDAString_iCompare(const char* s1, const char* s2);

extern REDADllExport int REDAString_inCompare(const char* s1, const char* s2, int n);

extern REDADllExport 
char * REDAString_strstrLast(const char *haystack, const char *needle);

extern REDADllExport 
char * REDAString_strstrnLast(
        const char *haystack, 
        size_t haystackLength, 
        const char *needle);

extern REDADllExport char * REDAString_iFindSubString(const char* s1, const char* s2);

extern REDADllExport
RTIBool REDAString_strToBoolean(
    const char * str, RTIBool *boolOut);

extern REDADllExport RTIBool REDAString_validateName(int* index,
                                                     int* diff,
                                                     char* inString,
                                                     char** referenceStrings,
                                                     RTIBool caseSensitive);



/*e \ingroup REDAStringClass
 * Function fnmatch() as specified in POSIX 1003.2-1992, section B.6.
 * Compares a filename or pathname to a pattern.
 */

/*e \ingroup REDAStringClass
 * fnmatch() return values. */
#define REDA_STRING_FNM_NOMATCH     1       /* Match failed. */

/* fnmatch() flags. */


/*e \ingroup REDAStringClass
  Normally, every occurrence of a backslash ('\') followed by a character
  in pattern is replaced by that character.

  If REDA_STRING_FNM_NOESCAPE flag is set, a backslash character in pattern
  parameter is treated as an ordinary character.
 */
#define REDA_STRING_FNM_NOESCAPE    0x01    /* Disable backslash escaping. */

/*e \ingroup REDAStringClass
  If the REDA_STRING_FNM_PATHNAME flag is not set, the / in string parameter is treated as
  an ordinary character.

  If the REDA_STRING_FNM_PATHNAME flag is set in the flags parameter, a / (slash) in the
  string parameter is explicitly matched by a / in the pattern parameter.
  It is not matched by either the * (asterisk) or ? (question-mark) special
  characters, nor by a bracket expression.
  Slash in the string parameter only matches slash in the pattern parameter.
 */
#define REDA_STRING_FNM_PATHNAME    0x02    /* Slash must be matched by slash. */

/*e \ingroup REDAStringClass
  If REDA_STRING_FNM_PERIOD is not set, no special restrictions are placed on matching a
  period in string parameter.

  If REDA_STRING_FNM_PERIOD is set in the flags parameter, then a leading period in the
  string parameter only matches a period in the pattern parameter;
  it is not matched by either the asterisk or question-mark special characters,
  not by a bracket expression. A period is determined to be leading according
  to the setting of the REDA_STRING_FNM_PATHNAME flag, according to the following rules:

  If the REDA_STRING_FNM_PATHNAME flag is set, a period is leading only if it is the
  first character in the string parameter or if it immediately follows a
  slash.

  If the REDA_STRING_FNM_PATHNAME flag is not set,  a period is leading only if it
  is the first character of the string parameter.
*/
#define REDA_STRING_FNM_PERIOD      0x04    /* Period must be matched by period. */

/*e \ingroup REDAStringClass
  If this flag is set, the pattern is considered to be matched if it
  matches an initial segment of string which is followed by a slash.
 */
#define REDA_STRING_FNM_LEADING_DIR 0x08    /* Ignore /<tail> after Imatch. */

/*e \ingroup REDAStringClass
  The pattern is matched in a case-insensitive fashion.
 */
#define REDA_STRING_FNM_CASEFOLD    0x10    /* Case insensitive search. */

/*e \ingroup REDAStringClass
  Applies if REDA_STRING_FNM_PATHNAME and NOT REDA_STRING_FNM_PERIOD.
  Redefines the path delimiter as a "." instead of a "/"
 */
#define REDA_STRING_FNM_DOTTED_PATH 0x20    /* Changes Slash to a Period */

/*e \ingroup REDAStringClass
 * Indicates if the matching is done between UTF-8 strings
 */
#define REDA_STRING_FNM_UTF8 0x40

/*e \ingroup REDAStringClass
 * Indicates if quotes should be removed from the input filter expression.
 * Quotes are not removed when using the SQL filter because the quotes are
 * considered part of the expression.
 * For example, the following filter expression:
 * "x MATCH '\\'hello\\''"
 * 
 * should match 'hello', not hello.
 * 
 * When the SQL filter is not being used, the quotes should be removed because
 * they are artifacts of how the expressions are stored in memory and not part
 * of the expression themselves.
 */
#define REDA_STRING_FNM_REMOVE_QUOTES 0x80


extern REDADllExport
int REDAString_fnmatch(const char *matchPattern, const char *matchString,
		       int matchFlags);

extern REDADllExport
int REDAString_isCommonPattern(
        const char *left,
        const char *right,
        void *flagRef);


typedef enum {
    SQL_OP_EQ,
    SQL_OP_NE,
    SQL_OP_GT,
    SQL_OP_LT,
    SQL_OP_GE,
    SQL_OP_LE,
    SQL_OP_BT,
    SQL_OP_MATCH
} SQLRelationshipKind;


typedef struct SQL_filter_term * SQL_filter_term_ptr;


typedef struct SQL_filter_term {
    SQL_filter_term_ptr next_AND;   /* next term in AND expression */
    SQL_filter_term_ptr next_OR;    /* next term in OR expression */
    SQL_filter_term_ptr tail;       /* last term in AND expression */
    SQL_filter_term_ptr clone_tail; /* last cloneable term in AND expression */
    char * field;                   /* sample field name */
    char * expr;                    /* filter expression */
    char * expr_two;                /* second expression for BETWEEN */
    SQLRelationshipKind opcode;     /* SQL opcode */
    RTIBool cloned;                 /* cloned node owns no memory */
} SQL_filter_term;


typedef struct {
    char *filterParameters;
    int parameterLength;
} SQL_filter_parameters;

extern REDADllExport
RTIBool REDAString_isSQLNumericRelationshipIntersect(
        SQL_filter_term * left, SQL_filter_term * right);

typedef enum {
    REDA_CHARACTER_ENCODING_UTF8,
    REDA_CHARACTER_ENCODING_ISO_8859_1,
    REDA_CHARACTER_ENCODING_UNKNOWN
} REDACharacterEncodingKind;

typedef enum {
    REDA_UNICODE_NORMALIZATION_OFF,
    REDA_UNICODE_NORMALIZATION_NFD,
    REDA_UNICODE_NORMALIZATION_NFC,
    REDA_UNICODE_NORMALIZATION_NFKD,
    REDA_UNICODE_NORMALIZATION_NFKC,
    REDA_UNICODE_NORMALIZATION_NFKC_CASEFOLD,
    REDA_UNICODE_NORMALIZATION_UNKNOWN
} REDAUnicodeNormalizationKind;

extern REDADllExport
RTIBool REDAString_hasIntersectingFilter(
        const char *s1,
        const char *s2,
        char c,
        SQL_filter_parameters *contentFilter,
        REDACharacterEncodingKind characterEncodingKind,
        REDAUnicodeNormalizationKind normalizationKind, 
        RTIBool supportsEscapedCharacters);

extern REDADllExport
RTIBool REDAString_strToLong(
    const char *str,
    RTI_INT32 *longOut);

extern REDADllExport
RTIBool REDAString_strToUnsignedShort(
    const char * str, RTI_UINT16 *shortOut);

extern REDADllExport
RTIBool REDAString_strToUnsignedLong(
    const char *str, RTI_UINT32 *unsignedLongOut);

extern REDADllExport char *
REDAString_strToken(char *s1, const char *delim, char **save);

extern REDADllExport char *
REDAString_strTokenNext(const char *s1, const char *delim, char **save);

extern REDADllExport
const char * REDAString_strstrEscaped(const char *str, const char *substr);

extern REDADllExport
RTI_INT32 REDAString_strcmpEscaped(const char *left, const char *right);

extern REDADllExport
const char *REDAString_getEscapedName(
        char *outName,
        RTI_UINT32 outNameLengthMax,
        const char *escapedName);


#define REDAString_nullSafe(str, strWhenNull) (str != NULL ? str : strWhenNull)

extern REDADllExport
REDACharacterEncodingKind REDACharacterEncodingKind_fromString(
      const char *str);

extern REDADllExport
REDAUnicodeNormalizationKind REDAUnicodeNormalizationKind_fromString(
        const char *str);


#define REDA_UNICODE_INVALID_UTF8 -1


#define REDA_UNICODE_NOT_ENOUGH_SPACE -2


#define REDA_UNICODE_ERROR -3


#define REDA_UNICODE_OK 0


typedef RTI_INT32 REDAUnicodeRetCode;

extern REDADllExport 
RTIBool REDAString_hasMatchingElementX(
        RTIBool *hasMatchingElement,
        const char* delimitorSeparatedString1,
        const char* delimitorSeparatedString2,
        char delimitor,
        RTI_INT32 flags,
        REDAUnicodeNormalizationKind normalizationKind,
        RTIBool tokenizeS1);

extern REDADllExport
REDAUnicodeRetCode REDAString_utf8Normalize(
        const char *str,
        char *normalizedStr,
        RTI_UINT32 *normalizedStrLength,
        REDAUnicodeNormalizationKind normalizationKind);

extern REDADllExport
REDAUnicodeRetCode REDAString_utf8Compare(
        int *result,
        const char *s1, 
        const char *s2,
        REDAUnicodeNormalizationKind normalizationKind);

extern REDADllExport
void REDAString_getCharAndNext(
        char **str, 
        RTI_INT32 *c,
        RTI_INT32 *encodingSize,
        REDACharacterEncodingKind encodingKind); 

/*e \ingroup REDAStringClass
 * @brief Gets the first character.
 * 
 * @param str \b In. The string.
 * @param c \b Out. Codepoint representing the first character.
 * @param encodingSize \b Out. Size of the first character.
 * @param encodingKind \In. Encoding kind.
 *
 * If the first character is not a valid UTF-8 character, the implementation
 * assumes that the character is one byte long.
 */
extern REDADllExport
void REDAString_getChar(
        const char *str, 
        RTI_INT32 *c, 
        RTI_INT32 *encodingSize,
        REDACharacterEncodingKind encodingKind); 

/*e \ingroup REDAStringClass
 * @brief Gets the character at position 'position'.
 * 
 * The position starts at 0.
 * 
 * @param str \b In. The string.
 * @param c \b Out. Codepoint representing the character at position.
 * @param encodingSize \b Out. Size of the the character at position.
 * @param position \b In. Character position.
 * @param encodingKind \In. Encoding kind.
 *
 * If any of the characters up to the one in position are not valid, the 
 * implementation assumes that all the characters including the one at position
 * are one byte long.
 */
extern REDADllExport
void REDAString_getCharAt(
        const char *str, 
        RTI_INT32 *c, 
        RTI_INT32 *encodingSize,
        RTI_INT32 position,
        REDACharacterEncodingKind encodingKind); 

/*e \ingroup REDAStringClass
 * @brief Advances to the next character.
 * 
 * @param str \b InOut. *str will be set to the position of the next character.
 * @param encodingKind \In. Encoding kind.
 *
 * If the next character is not a valid UTF-8 character, the implementation
 * assumes that the next character is one byte long.
 */
extern REDADllExport
void REDAString_nextChar(
        const char **str,
        REDACharacterEncodingKind encodingKind);

extern REDADllExport
void REDAString_prevChar(
        const char **str, 
        REDACharacterEncodingKind encodingKind);

extern REDADllExport
RTI_INT32 REDAChar_toLower(RTI_INT32 c);

extern REDADllExport
RTI_INT32 REDAChar_toUpper(RTI_INT32 c);


#include "reda/reda_string_impl.h"


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* reda_string_h */
