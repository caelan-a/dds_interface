/* (c) Copyright 2003-2021, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_concurrentQueue.h    generated by: makeheader    Fri Apr 23 00:10:54 2021
 *
 *		built from:	concurrentQueue.ifc
 */

#ifndef reda_concurrentQueue_h
#define reda_concurrentQueue_h


  #include <stdio.h> /* for FILE */
  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif
  #ifndef reda_dll_h
    #include "reda/reda_dll.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif


  #define REDA_CONCURRENT_QUEUE_MSG_ALIGN_BYTES (8)


  #define REDA_CONCURRENT_QUEUE_COOKIE_INVALID (0)

struct REDAConcurrentQueueHandle;

struct REDAConcurrentQueueDesc {
    /*e Maximum number of bytes of all messages in the buffer */
    int _maxDataBytes;
    /*e Maximum number of bytes on a single write/read */
    int _messageSizeMax;
    /*e Maximum number of individual messages the buffer can hold */
    int _messageCountMax;
    /*e The memory address passed to the create or attach call */
    const char *_memAddress;
};

struct REDAConcurrentQueueStateInfo {
    /*e Total number of bytes ever written to the queue since it was
        created */
    unsigned int _bytesWrittenCounter;
    /*e Total number of bytes ever read from the queue since it was
       created */
    unsigned int _bytesFullyReadCounter;
    /*e Boolean flag indicating whether the next message in the queue
       is ready to be read. In other words, whether the next call
       to REDAConcurrentQueue_startReadEA will return a message
       */
    RTIBool      _nextToBeReadMsgIsReadyToRead;
    /*e Boolean flag indicating whether the next message in the queue
       is still being written. In other words, whether a writer has
       called REDAConcurrentQueue_startWriteEA but has not yet
       called REDAConcurrentQueue_finishWriteEA
       */
    RTIBool      _nextToBeReadMsgIsBeingWritten;
    /*e Size of the message that will be returned by the next call to
       REDAConcurrentQueue_startReadEA, assuming it is known.
       */
    int          _nextToBeReadMsgSize;
    /*e In the event that _nextToBeeadMsgIsBeingWritten==RTI_TRUE, this
       field contains the value of the finishedHandle that the writer
       writing that message should be used as a parameter to
       REDAConcurrentQueue_finishWriteEA
       */
    int          _nextToBeReadMsgWriteFinishHandle;
    /*e In the event that _nextToBeeadMsgIsBeingWritten==RTI_TRUE, this
       field contains the value of the cookie that the writer
       writing that message used in the call to
       REDAConcurrentQueue_startWriteEA
       */
    unsigned int _nextToBeReadMsgWriterCookie;
    /*e Boolean flag indicating whether there is one (or more) messages
       in the process of being read.
     */
    RTIBool      _haveMsgBeingRead;
    /*e In the event that _haveMsgBeingRead==RTI_TRUE this field contains
       the size of the 'first' message that is still being read. "First"
       detemined by the order in which REDAConcurrentQueue_startReadEA was
       called.
       */
    int          _nextBeingReadMsgSize;
    /*e In the event that _haveMsgBeingRead==RTI_TRUE this field contains
       the finishHandle of the 'first' message that is still being read.
       That is the finishHandle that should be passed to the
       REDAConcurrentQueue_finishReadEA to indicate the message has been
       completely read
       */
    int          _nextBeingReadMsgReadFinishHandle;
    /*e In the event that _haveMsgBeingRead==RTI_TRUE this field contains
       the value of the cookie that the reader
       reading that message used in the call to REDAConcurrentQueue_startReadEA
       */
    unsigned int _nextBeingReadMsgReaderCookie;
};


struct REDAConcurrentQueueVersion {
    char major;
    char minor;
};

extern REDADllVariable
const struct REDAConcurrentQueueVersion REDA_CONCURRENT_QUEUE_VERSION_BEFORE_BUG_14240_FIX;

extern REDADllVariable
const struct REDAConcurrentQueueVersion REDA_CONCURRENT_QUEUE_VERSION_AFTER_BUG_14240_FIX;

extern REDADllVariable
const struct REDAConcurrentQueueVersion REDA_CONCURRENT_QUEUE_VERSION_AFTER_WRITER_COOKIE_SUPPORT;

extern REDADllVariable
const struct REDAConcurrentQueueVersion REDA_CONCURRENT_QUEUE_VERSION_DEFAULT;


/*
 * Default version values for the concurrent queue. This must always be the
 * latest queue version.
 * See REDA_CONCURRENT_QUEUE_VERSION_DEFAULT.
 */
#define REDA_CONCURRENT_QUEUE_VERSION_DEFAULT_MAJOR (4)
#define REDA_CONCURRENT_QUEUE_VERSION_DEFAULT_MINOR (0)

#define REDAConcurrentQueueProperty_INITIALIZER { \
  { \
    REDA_CONCURRENT_QUEUE_VERSION_DEFAULT_MAJOR, \
    REDA_CONCURRENT_QUEUE_VERSION_DEFAULT_MINOR \
  } \
}


struct REDAConcurrentQueueProperty {
    struct REDAConcurrentQueueVersion version;
};

extern REDADllExport
RTIBool REDAConcurrentQueue_createWithProperty(
        struct REDAConcurrentQueueHandle *q,
        int messageCountMax,
        int messageSizeMax,
        char *memAddress,
        int memAddressNumBytes,
        const struct REDAConcurrentQueueProperty *property);

extern REDADllExport RTIBool
REDAConcurrentQueue_create(
        struct REDAConcurrentQueueHandle *q,
        int messageCountMax,
        int messageSizeMax,
        char *memAddress,
        int memAddressNumBytes);

extern REDADllExport RTIBool
REDAConcurrentQueue_unlink(struct REDAConcurrentQueueHandle *q);

extern REDADllExport RTIBool
REDAConcurrentQueue_attach(struct REDAConcurrentQueueHandle *q, char *memAddress);

extern REDADllExport RTIBool
REDAConcurrentQueue_detach(struct REDAConcurrentQueueHandle *q);

extern REDADllExport
int REDAConcurrentQueue_getSizeRequired(
        int messageSizeMax,
        int messageCountMax,
        int maxBytesBuffered,
        const struct REDAConcurrentQueueVersion *queueVersion);

extern REDADllExport
void REDAConcurrentQueue_print(const struct REDAConcurrentQueueHandle *q, 
			       FILE *file);

extern REDADllExport
RTIBool REDAConcurrentQueue_startWriteEA(struct REDAConcurrentQueueHandle *q,
					 int *finishedHandle, char **whereTo,
					 int msgSize, unsigned int cookie);

extern REDADllExport
void REDAConcurrentQueue_finishWrite(
        struct REDAConcurrentQueueHandle *q,
        int finishedHandle,
        int msgSize);

extern REDADllExport
int REDAConcurrentQueue_startReadEA(struct REDAConcurrentQueueHandle *q,
			       int *finishedHandle, char **whereFrom,
                               unsigned int readerCookie);

extern REDADllExport
void REDAConcurrentQueue_finishReadEA(
        struct REDAConcurrentQueueHandle *q,
        int finishedHandle);

extern REDADllExport
void REDAConcurrentQueue_getQueueDesc(
    struct REDAConcurrentQueueHandle *q,
    struct REDAConcurrentQueueDesc *descOut);

extern REDADllExport
void REDAConcurrentQueue_getQueueStateInfoReadEA(
    struct REDAConcurrentQueueHandle *q,
    struct REDAConcurrentQueueStateInfo *infoOut);

extern REDADllExport
RTIBool REDAConcurrentQueue_isWriterPotentiallyStuck(
    struct REDAConcurrentQueueHandle *q,
    struct REDAConcurrentQueueStateInfo *previousInfo,
    struct REDAConcurrentQueueStateInfo *currentInfo );

extern REDADllExport
RTIBool REDAConcurrentQueue_isReaderPotentiallyStuck(
    struct REDAConcurrentQueueHandle *q,
    struct REDAConcurrentQueueStateInfo *previousInfo,
    struct REDAConcurrentQueueStateInfo *currentInfo );

extern REDADllExport
void REDAConcurrentQueue_flushReadEA(
        struct REDAConcurrentQueueHandle *q,
        int readCookie);

extern REDADllExport
const RTI_UINT32 * REDAConcurrentQueue_getCookieFromHandle(
        struct REDAConcurrentQueueHandle *queueHandle,
        int *bufferHandle);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

/* pick up hidden performance boosting macros and optimizations */
  #include "reda/reda_concurrentQueue_impl.h"

#endif /* reda_concurrentQueue_h */
