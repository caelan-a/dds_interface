/* (c) Copyright 2003-2021, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_concurrentQueue_impl.h    generated by: makeheader    Fri Apr 23 00:10:54 2021
 *
 *		built from:	concurrentQueue_impl.ifc
 */

#ifndef reda_concurrentQueue_impl_h
#define reda_concurrentQueue_impl_h


  #include <stddef.h>
  #ifndef reda_memory_h
/*    #include "reda/reda_memory.h"*/
  #endif

#ifdef __cplusplus
    extern "C" {
#endif


struct REDAConcurrentQueueMsgInfo {
    int          _size;
    unsigned int _cookie;
    RTI_UINT32 _writerCookie;
};


struct REDAConcurrentQueueMsgInfoV3 {
    int          _size;
    unsigned int _cookie;
};

struct REDAConcurrentQueueHandle {
    /* Copy of the Parameters used to configure the queue
     * when it was created. Should be considered constant and read-only
     */
    struct REDAConcurrentQueueDesc _desc;

    /* If a byte swap is required since writing to a different endian 
     * representation.
     */
    int _adjustForEndianness;

    /* Points to the shared state of the queue */
    struct REDAConcurrentQueueState *_state;

    /* Points to a backup of the state. Uset to restore the state if
     a process crashes while modifying the state
    */
    struct REDAConcurrentQueueState *_backup;

    /*
     * Together with the bufferReadIndex defines the array of messages. Must be
     * able to hold messageCountMax+1 elements.
     *
     * The type of _msgInfos is void so that using it requires a cast.
     * The final type depends on the version of the queue.
     * Possible values: REDAConcurrentQueueMsgInfo and
     * REDAConcurrentQueueMsgInfoV3.
     */
    void *_msgInfos;

    /*
     * The buffer containing the messages. Contains space for bufferSize bytes
     * Note that always: bufferSize > (maxDataBytes + messageSizeMax)
     * in fact currently we set
     *     bufferSize = (maxDataBytes + messageSizeMax)
     *          + (REDA_CONCURRENT_QUEUE_ALIGN_BYTES -1)*messageSizeMax
     */
    char *_buffer;

    /* The number of bytes available for using starting at buffer */
    unsigned int _bufferSize;
};


struct REDAConcurrentQueueSignature {
    char firstByte;     /* should be 'C' */
    char secondByte;    /* should be 'Q' */
    struct REDAConcurrentQueueVersion version;
};


struct REDAConcurrentQueueHeader {
    /*
     * Note the layout of the header CANNOT be modified.
     * It will break interoperability */
    /* BEGIN --------- DO NOT MODIFY AREA --------------------- */
    struct REDAConcurrentQueueSignature _signature;

    /*
     * Indicates whether the values in the header are stored in
     * little-endian or big endian notation.
     * The flag _sharedIsQueueHeaderBigEndian should only be compared
     * for (in)equality with zero. That way we don't have to
     * worry about the endianess of the the flag
     */
    RTIBool                          _sharedIsQueueHeaderBigEndian;
    int                              _sharedBufferSize;
    int                              _sharedOffsetToState;
    int                              _sharedOffsetToStateBackup;
    int                              _sharedOffsetToMsgInfos;
    int                              _sharedOffsetToBuffer;
    int                              _sharedSizeofInt;
    struct REDAConcurrentQueueDesc   _sharedQueueDescription;
    /* END --------- DO NOT MODIFY AREA --------------------- */

    /*
     * Header can be expanded with additional information below this expansion
     * will not break interoperability
     */
};


#define swap4ByteUIntArg(x) ( \
    (unsigned int) (((x)<<24) | (((x)&0xff00)<<8)) \
    | (unsigned int) ((((x)&0xff0000)>>8) | ((x)>>24)) \
)
#define swap4Bytes(x) swap4ByteUIntArg( ((unsigned int)(x)) )


#define REDAConcurrentQueueVersion_isV3OrLower(__version) \
    ((__version).major < REDA_CONCURRENT_QUEUE_VERSION_AFTER_WRITER_COOKIE_SUPPORT.major \
        ? RTI_TRUE \
        : (__version).minor < REDA_CONCURRENT_QUEUE_VERSION_AFTER_WRITER_COOKIE_SUPPORT.minor)

#define REDAConcurrentQueue_finishWrite( \
    __q, \
    __finishedHandle, \
    __msgSize) \
  if (REDAConcurrentQueueVersion_isV3OrLower( \
      ((struct REDAConcurrentQueueHeader *) (__q)->_desc._memAddress)->_signature.version)) { \
    struct REDAConcurrentQueueMsgInfoV3 *__msgInfo = \
        (struct REDAConcurrentQueueMsgInfoV3 *) (__q)->_msgInfos; \
\
    __msgInfo[__finishedHandle]._size = (__q)->_adjustForEndianness \
        ? (int) swap4Bytes(__msgSize) \
        : (__msgSize); \
    __msgInfo[__finishedHandle]._cookie = REDA_CONCURRENT_QUEUE_COOKIE_INVALID; \
  } else { \
    struct REDAConcurrentQueueMsgInfo *__msgInfo = \
        (struct REDAConcurrentQueueMsgInfo *) (__q)->_msgInfos; \
\
    __msgInfo[__finishedHandle]._size = (__q)->_adjustForEndianness \
        ? (int) swap4Bytes(__msgSize) \
        : (__msgSize); \
    __msgInfo[__finishedHandle]._cookie = REDA_CONCURRENT_QUEUE_COOKIE_INVALID; \
    }

#define REDAConcurrentQueue_getQueueDesc(q, descOut) *(descOut) = (q)->_desc


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* reda_concurrentQueue_impl_h */
