/* (c) Copyright 2003-2021, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)transport_common.h    generated by: makeheader    Fri Apr 23 00:11:21 2021
 *
 *		built from:	common.ifc
 */

#ifndef transport_common_h
#define transport_common_h


#ifndef osapi_type_h
#include "osapi/osapi_type.h"
#endif

#ifndef osapi_rtpsGuid_h
#include "osapi/osapi_rtpsGuid.h"
#endif

#ifndef reda_buffer_h
#include "reda/reda_buffer.h"
#endif

#ifndef transport_dll_h
#include "transport/transport_dll.h"
#endif

/* Include the APIs useful for the transport plugin user */
#ifndef transport_common_user_h
  #include "transport/transport_common_user.h"
#endif

#ifdef __cplusplus
    extern "C" {
#endif


typedef RTI_UINT32 NDDS_Transport_Port_t;


#define NDDS_TRANSPORT_PORT_INVALID ((NDDS_Transport_Port_t) 0) 


struct NDDS_Transport_SharedPort_t {
    NDDS_Transport_Port_t port;
    int ref_count;
};


#define NDDS_TRANSPORT_UUID_SIZE 12


struct NDDS_Transport_UUID {
    unsigned char value[NDDS_TRANSPORT_UUID_SIZE];
};


#define NDDS_TRANSPORT_UUID_UNKNOWN {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}

 
typedef enum {
  /*e
    \brief The transport interface is OFF.
   */
  NDDS_TRANSPORT_INTERFACE_OFF  = 0,
  /*e 
    \brief The transport interface is ON.
   */
  NDDS_TRANSPORT_INTERFACE_ON   = 1
} NDDS_Transport_Interface_Status_t;

 
typedef struct {
     /*e
       \brief The transport classid of the interface.
      */
     NDDS_Transport_ClassId_t transport_classid;
     
     /*e 
       \brief An unicast address that uniquely identifies this 
       interface in the network specified by the transport class.
      */    
     NDDS_Transport_Address_t address; 

    /*e
      \brief The state of the interface
     */
    NDDS_Transport_Interface_Status_t status;
     
} NDDS_Transport_Interface_t;


#define NDDS_TRANSPORT_INTERFACE_INITIALIZER \
{ \
    NDDS_TRANSPORT_CLASSID_INVALID, \
    NDDS_TRANSPORT_ADDRESS_INVALID_INITIALIZER, \
    NDDS_TRANSPORT_INTERFACE_OFF \
}

extern NDDS_Transport_DllExport
void NDDS_Transport_Interface_print(
    const NDDS_Transport_Interface_t *interface_in, 
    const char                       *desc_in, 
    RTI_INT32                         indent_in);


#define NDDS_TRANSPORT_CONTEXT_INVALID \
{ \
    NDDS_TRANSPORT_ADDRESS_INVALID_INITIALIZER, \
    NDDS_TRANSPORT_ADDRESS_INVALID_INITIALIZER, \
    NDDS_TRANSPORT_PORT_INVALID,    \
    NDDS_TRANSPORT_PORT_INVALID,    \
    NDDS_TRANSPORT_PORT_INVALID,    \
    NDDS_TRANSPORT_CLASSID_INVALID  \
}


struct NDDS_Transport_Context_t {
    /*i
     * @brief Source address of the message.
     */
    NDDS_Transport_Address_t sourceAddress;
    /*i
     * @brief Destination address of the message.
     */
    NDDS_Transport_Address_t destinationAddress;
    /*i
     * @brief source port of the message.
     */
    NDDS_Transport_Port_t    sourcePort;
    /*i
     * @brief Destination port of the message.
     * In the case of TCP, if participant is acting as server,
     * this is the server bind port.
     */
    NDDS_Transport_Port_t    destinationPort;
    /*i
     * @brief RTPS port when TCP and participant acting as server.
     * Otherwise, destinationRTPSPort is equal to 0 and we are assuming
     * destinationRTPSPort==destinationPort.
     */
    NDDS_Transport_Port_t    destinationRTPSPort;
    /*i
     * @brief Transport class Id. This information is filled by netio.
     */
    NDDS_Transport_ClassId_t classId;
};


#define NDDS_TRANSPORT_PRIORITY_DEFAULT (0)

typedef struct REDABuffer NDDS_Transport_Buffer_t;


#define NDDS_Transport_Buffer_t_compare(transportBuffer1, transportBuffer2) \
      (((transportBuffer1)->length < (transportBuffer2)->length) ? -1 : \
       (((transportBuffer1)->length > (transportBuffer2)->length) ?  1 : \
        (((transportBuffer1)->pointer < (transportBuffer2)->pointer) ? -1 : \
         (((transportBuffer1)->pointer > (transportBuffer2)->pointer) ? 1 : 0 ))))


#ifdef __cplusplus
    }	/* extern "C" */
#endif

  #include "transport/transport_common_impl.h"

#endif /* transport_common_h */
