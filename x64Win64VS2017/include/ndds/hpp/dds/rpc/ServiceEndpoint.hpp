#ifndef OMG_DDS_RPC_SERVICEENDPOINT_
#define OMG_DDS_RPC_SERVICEENDPOINT_

/*
(c) Copyright, Real-Time Innovations, 2020
All rights reserved.

No duplications, whole or partial, manual or electronic, may be made
without express written permission.  Any such copies, or
revisions thereof, must display this notice unaltered.
This code contains trade secrets of Real-Time Innovations, Inc.
*/

// IMPORTANT: macros.hpp must be the first RTI header included in every header
// file so that symbols are exported correctly on Windows
#include <dds/core/macros.hpp>

#if !defined(RTI_NO_CXX11_RPC_SUPPORT)

#include "dds/rpc/Server.hpp"
#include "rti/request/Replier.hpp"

#include "dds/rpc/detail/ServiceEndpoint.hpp"
#include "dds/rpc/ServiceParams.hpp"

namespace dds { namespace rpc {

/**
 * @defgroup RpcServiceModule Server-side API
 * @ingroup RpcModule
 * @brief Part of the RPC API that relates to the Server and ServiceEndpoint
 */

/**
 * @ingroup RpcServiceModule
 * @brief Manages the DDS entities required to receive function calls and
 * send the return values.
 *
 * @tparam Dispatcher Internal type generated by `rtiddsgen`
 *
 * Applications shouldn't use this class directly. `rtiddsgen` will generate
 * the proper instantiation of this class, such as rpc_example::RobotControlService
 *
 * A ServiceEndpoint requires a an implementation of an IDL service interface,
 * such as rpc_example::RobotControl.
 *
 * A ServiceEndpoint is attached to a Server in order to start
 * receiving and processing remote function calls.
 *
 */
template <typename Dispatcher>
class ServiceEndpoint
        : public dds::core::Reference<detail::ServiceEndpointImpl<Dispatcher>> {
private:
    using Delegate = detail::ServiceEndpointImpl<Dispatcher>;
    using Base = dds::core::Reference<Delegate>;

public:
    /**
     * @brief The interface type, such as rpc_example::RobotControl
     */
    using InterfaceType = typename Dispatcher::InterfaceType;

    /**
     * @brief The internal type used to receive requests (function calls)
     */
    using RequestType = typename Dispatcher::RequestType;

    /**
     * @brief The internal type used to send replies (the return values of the
     * function calls)
     */
    using ReplyType = typename Dispatcher::ReplyType;

    OMG_DDS_REF_TYPE_NODC(ServiceEndpoint, dds::core::Reference, Delegate)

    // TODO: spec: this ctor doesnt' make sense. See TODO in TServerParams
    //
    // ServiceEndpoint(
    //         std::shared_ptr<InterfaceType> service_impl,
    //         dds::rpc::Server server)
    //         : Base(new Delegate(service_impl, server));

    /**
     * @brief Construct a new Service Endpoint object
     *
     * @param service_impl The implementation of the DDS service, such as
     * rpc_example::RobotControl.
     * @param server The server where to run this service endpoint.
     * @param params The parameters used to configure this service endpoint
     */
    ServiceEndpoint(
            std::shared_ptr<InterfaceType> service_impl,
            dds::rpc::Server server,
            const ServiceParams& params)
            : Base(new Delegate(service_impl, server, params))
    {
    }

    /**
     * @brief Destroys the underlying resources
     *
     * Any operation after close() throws dds::core::AlreadyClosedError
     */
    void close()
    {
        this->delegate()->close_impl();
    }

    /**
     * @brief Accesses the underlying DataReader that receives the requests
     * (function calls)
     *
     * @return The DataReader
     */
    dds::sub::DataReader<RequestType> request_datareader()
    {
        return this->delegate()->request_datareader_impl();
    }

    /**
     * @brief Accesses the underlying DataWriter that sends the replies
     * (return values from the function calls)
     *
     * @return The DataWriter
     */
    dds::pub::DataWriter<ReplyType> reply_datawriter()
    {
        return this->delegate()->reply_datawriter_impl();
    }
};

} }

#endif  // !defined(RTI_NO_CXX11_RPC_SUPPORT)

#ifdef DOXYGEN_DOCUMENTATION_ONLY

namespace rpc_example {

/**
 * @ingroup RpcModule
 *
 * @brief The synchronous interface generated from the \ref RpcModule
 * "RobotControl" IDL service.
 *
 * RobotControlClient implements this interface to make synchronous remote
 * function calls.
 *
 * Server-side applications must implement this interface to handle remote
 * calls. To execute an implementation of this interface, create a
 * \ref RpcServiceModule "RobotControlService".
 */
class RobotControl {
public:
    /**
     * @brief An IDL interface method defined in RobotControl
     *
     * @param destination An input argument
     * @param speed An input argument
     * @return A return value
     */
    virtual Coordinates walk_to(
            const Coordinates& destination,
            float speed) = 0;

    /**
     * @brief An IDL interface method defined in RobotControl
     *
     * @return The return value of this method
     */
    virtual float get_speed() = 0;

    /**
     * @brief An empty virtual destructor
     */
    virtual ~RobotControl()
    {
    }
};

/**
 * @ingroup RpcModule
 *
 * @brief The asynchronous interface derived from the RobotControl service
 *
 * RobotControlClient implements this interface to make asynchronous remote
 * function calls.
 *
 * This interface is not implemented on the server side.
 */
class RobotControlAsync {
public:
    /**
     * @brief An IDL interface method defined in RobotControl
     *
     * @param destination An input argument
     * @param speed An input argument
     * @return The future return value
     */
    virtual std::future<Coordinates> walk_to_async(
            const Coordinates& destination,
            float speed) = 0;

    /**
     * @brief An IDL interface method defined in RobotControl
     */
    virtual std::future<float> get_speed_async() = 0;

    /**
     * @brief An empty virtual destructor
     */
    virtual ~RobotControlAsync()
    {
    }
};

/**
 * @ingroup RpcServiceModule
 * @brief Executes a RobotControl interface implementation
 */
using RobotControlService = dds::rpc::ServiceEndpoint<RobotControlDispatcher> ;

} // rpc_example

namespace dds { namespace rpc  {

/**
 * @ingroup RpcServiceModule
 * @brief The parameters used to configure a ServiceEndpoint
 */
using ServiceParams = rti::request::ReplierParams;

} }

#endif  // DOXYGEN_DOCUMENTATION_ONLY

#endif  // OMG_DDS_RPC_SERVICEENDPOINT_
